## Примеры use case графовых баз

1. Рекомендательные системы (движки)

C помощью граф. базы можно отслеживатпь поведение пользователя и создавать новые точки интереса, предоставляя соответствующие рекомендации

- [x] За счет возможности давать нодам неограниченное кол-во <em>label</em>, можно в реальном времени типизировать различные продукты
- [x] <em>Relation type</em> позволяет "контекстуализировать" данные, что необходимо для рекомендательных систем

2. Логистические/производственные цепочки

С помощью графовых БД можно производить создание и анализ производственных цепочек, 
по типу ``Cклад B - (доставляет X на) - завод A``.

- [x] Алгоритмы из области теории графов позволят строить оптимальные маршруты и легко откликаться на изменения данных в реальном времени (въезд запретили, поставщик не доступен и т.д)
- [x] Простота построения иерархических структур, отражающих положение бизнеса

## Примеры вещей которые проще делать в графовой базе данных

1. Все что связано с нахождением пути ('проходом, поиском в глубину/ширину...')

Предположим что имееются данные, кортежи местоположений <A,B> (направление опускается для удобства). 
Необходимо найти кратчайший путь до точки B 

Наша реляционная таблица бы выглядела следующим образом:

| a | b |
|---|---|
| 1 | 2 |
| 1 | 3 |
| 2 | 4 |
| 3 | 4 |

SQL-решение вынуждает нас использовать рекурсивные запросы, неудобный и непонятный запрос/синтаксис

```sql
with recursive cte as (
      select f, t, 1 as lev, (f || '->' || t) as path
      from edges
      where f = 1
      union all
      select e.f, e.t, lev + 1 , (cte.path || '->' || e.t) as path
      from cte join
           edges e
           on e.f = cte.t
      where lev < 100 or e.t = 4
     )
select cte.*
from cte
where cte.t = 4
order by lev
limit 1
```

Neo4j [предлагает нам](https://neo4j.com/docs/cypher-manual/current/appendix/tutorials/shortestpath-planning/) написать одну функцию между интересующими нодами

```sql
MATCH
  (KevinB:Person {name: 'Kevin Bacon'}),
  (Al:Person {name: 'Al Pacino'}),
  p = shortestPath((KevinB)-[:ACTED_IN*]-(Al))
WHERE all(r IN relationships(p) WHERE r.role IS NOT NULL)
RETURN p
```

2. Реализация наследования

Наследование в SQL, которое является по сути хаком из-за того что реляционнные базы данных понимают только *has a* отношение, считается плохой практикой 

Есть множество способов реализации наследования (которые повлекут за собой определенные минусы):

1) Единая таблица для всей иерархии классов, тип будет определяться через строку/enum
2) Одна таблица для каждого конкретного класса
3) Одна таблица для каждого подкласса, связь с родительской таблицей через JOIN

В Neo4j все проще, при [создании ноды](https://neo4j.com/docs/cypher-manual/current/clauses/create/#create-nodes) мы можем просто указать с какими типами она будет ассоциироваться

```sql
CREATE (charlie:Person:Actor {name: 'Charlie Sheen'})...
```

